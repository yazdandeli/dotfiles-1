{"version":3,"sources":["out-vscode/vs/base/node/languagePacks.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\n//@ts-check\n\n/**\n * @param {NodeRequire} nodeRequire\n * @param {typeof import('path')} path\n * @param {typeof import('fs')} fs\n * @param {typeof import('../common/performance')} perf\n */\nfunction factory(nodeRequire, path, fs, perf) {\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<boolean>}\n\t */\n\tfunction exists(file) {\n\t\treturn new Promise(c => fs.exists(file, c));\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<void>}\n\t */\n\tfunction touch(file) {\n\t\treturn new Promise((c, e) => { const d = new Date(); fs.utimes(file, d, d, err => err ? e(err) : c()); });\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<object>}\n\t */\n\tfunction lstat(file) {\n\t\treturn new Promise((c, e) => fs.lstat(file, (err, stats) => err ? e(err) : c(stats)));\n\t}\n\n\t/**\n\t * @param {string} dir\n\t * @returns {Promise<string[]>}\n\t */\n\tfunction readdir(dir) {\n\t\treturn new Promise((c, e) => fs.readdir(dir, (err, files) => err ? e(err) : c(files)));\n\t}\n\n\t/**\n\t * @param {string} dir\n\t * @returns {Promise<string>}\n\t */\n\tfunction mkdirp(dir) {\n\t\treturn new Promise((c, e) => fs.mkdir(dir, { recursive: true }, err => (err && err.code !== 'EEXIST') ? e(err) : c(dir)));\n\t}\n\n\t/**\n\t * @param {string} dir\n\t * @returns {Promise<void>}\n\t */\n\tfunction rmdir(dir) {\n\t\treturn new Promise((c, e) => fs.rmdir(dir, err => err ? e(err) : c(undefined)));\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<void>}\n\t */\n\tfunction unlink(file) {\n\t\treturn new Promise((c, e) => fs.unlink(file, err => err ? e(err) : c(undefined)));\n\t}\n\n\t/**\n\t * @param {string} location\n\t * @returns {Promise<void>}\n\t */\n\tfunction rimraf(location) {\n\t\treturn lstat(location).then(stat => {\n\t\t\tif (stat.isDirectory() && !stat.isSymbolicLink()) {\n\t\t\t\treturn readdir(location)\n\t\t\t\t\t.then(children => Promise.all(children.map(child => rimraf(path.join(location, child)))))\n\t\t\t\t\t.then(() => rmdir(location));\n\t\t\t} else {\n\t\t\t\treturn unlink(location);\n\t\t\t}\n\t\t}, err => {\n\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tthrow err;\n\t\t});\n\t}\n\n\tfunction readFile(file) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tfs.readFile(file, 'utf8', function (err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve(data);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @param {string} content\n\t * @returns {Promise<void>}\n\t */\n\tfunction writeFile(file, content) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tfs.writeFile(file, content, 'utf8', function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t}\n\n\n\t/**\n\t * @param {string} userDataPath\n\t * @returns {object}\n\t */\n\tfunction getLanguagePackConfigurations(userDataPath) {\n\t\tconst configFile = path.join(userDataPath, 'languagepacks.json');\n\t\ttry {\n\t\t\t// NOTE@coder: Swapped require with readFile since require is cached and\n\t\t\t// we don't restart the server-side portion of code-server when the\n\t\t\t// language changes.\n\t\t\treturn JSON.parse(fs.readFileSync(configFile, 'utf8'));\n\t\t} catch (err) {\n\t\t\t// Do nothing. If we can't read the file we have no\n\t\t\t// language pack config.\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {object} config\n\t * @param {string} locale\n\t */\n\tfunction resolveLanguagePackLocale(config, locale) {\n\t\ttry {\n\t\t\twhile (locale) {\n\t\t\t\tif (config[locale]) {\n\t\t\t\t\treturn locale;\n\t\t\t\t} else {\n\t\t\t\t\tconst index = locale.lastIndexOf('-');\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\tlocale = locale.substring(0, index);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error('Resolving language pack configuration failed.', err);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {string} commit\n\t * @param {string} userDataPath\n\t * @param {string} metaDataFile\n\t * @param {string} locale\n\t */\n\tfunction getNLSConfiguration(commit, userDataPath, metaDataFile, locale) {\n\t\tif (locale === 'pseudo') {\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {}, pseudo: true });\n\t\t}\n\n\t\tif (process.env['VSCODE_DEV']) {\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {} });\n\t\t}\n\n\t\t// We have a built version so we have extracted nls file. Try to find\n\t\t// the right file to use.\n\n\t\t// Check if we have an English or English US locale. If so fall to default since that is our\n\t\t// English translation (we don't ship *.nls.en.json files)\n\t\tif (locale && (locale === 'en' || locale === 'en-us')) {\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {} });\n\t\t}\n\n\t\tconst initialLocale = locale;\n\n\t\tperf.mark('code/willGenerateNls');\n\n\t\tconst defaultResult = function (locale) {\n\t\t\tperf.mark('code/didGenerateNls');\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {} });\n\t\t};\n\t\ttry {\n\t\t\tif (!commit) {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\tconst configs = getLanguagePackConfigurations(userDataPath);\n\t\t\tif (!configs) {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\tlocale = resolveLanguagePackLocale(configs, locale);\n\t\t\tif (!locale) {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\tconst packConfig = configs[locale];\n\t\t\tlet mainPack;\n\t\t\tif (!packConfig || typeof packConfig.hash !== 'string' || !packConfig.translations || typeof (mainPack = packConfig.translations['vscode']) !== 'string') {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\treturn exists(mainPack).then(fileExists => {\n\t\t\t\tif (!fileExists) {\n\t\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t\t}\n\t\t\t\tconst packId = packConfig.hash + '.' + locale;\n\t\t\t\tconst cacheRoot = path.join(userDataPath, 'clp', packId);\n\t\t\t\tconst coreLocation = path.join(cacheRoot, commit);\n\t\t\t\tconst translationsConfigFile = path.join(cacheRoot, 'tcf.json');\n\t\t\t\tconst corruptedFile = path.join(cacheRoot, 'corrupted.info');\n\t\t\t\tconst result = {\n\t\t\t\t\tlocale: initialLocale,\n\t\t\t\t\tavailableLanguages: { '*': locale },\n\t\t\t\t\t_languagePackId: packId,\n\t\t\t\t\t_translationsConfigFile: translationsConfigFile,\n\t\t\t\t\t_cacheRoot: cacheRoot,\n\t\t\t\t\t_resolvedLanguagePackCoreLocation: coreLocation,\n\t\t\t\t\t_corruptedFile: corruptedFile\n\t\t\t\t};\n\t\t\t\treturn exists(corruptedFile).then(corrupted => {\n\t\t\t\t\t// The nls cache directory is corrupted.\n\t\t\t\t\tlet toDelete;\n\t\t\t\t\tif (corrupted) {\n\t\t\t\t\t\ttoDelete = rimraf(cacheRoot);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttoDelete = Promise.resolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t\treturn toDelete.then(() => {\n\t\t\t\t\t\treturn exists(coreLocation).then(fileExists => {\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\t// We don't wait for this. No big harm if we can't touch\n\t\t\t\t\t\t\t\ttouch(coreLocation).catch(() => { });\n\t\t\t\t\t\t\t\tperf.mark('code/didGenerateNls');\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn mkdirp(coreLocation).then(() => {\n\t\t\t\t\t\t\t\treturn Promise.all([readFile(metaDataFile), readFile(mainPack)]);\n\t\t\t\t\t\t\t}).then(values => {\n\t\t\t\t\t\t\t\tconst metadata = JSON.parse(values[0]);\n\t\t\t\t\t\t\t\tconst packData = JSON.parse(values[1]).contents;\n\t\t\t\t\t\t\t\tconst bundles = Object.keys(metadata.bundles);\n\t\t\t\t\t\t\t\tconst writes = [];\n\t\t\t\t\t\t\t\tfor (const bundle of bundles) {\n\t\t\t\t\t\t\t\t\tconst modules = metadata.bundles[bundle];\n\t\t\t\t\t\t\t\t\tconst target = Object.create(null);\n\t\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst keys = metadata.keys[module];\n\t\t\t\t\t\t\t\t\t\tconst defaultMessages = metadata.messages[module];\n\t\t\t\t\t\t\t\t\t\tconst translations = packData[module];\n\t\t\t\t\t\t\t\t\t\tlet targetStrings;\n\t\t\t\t\t\t\t\t\t\tif (translations) {\n\t\t\t\t\t\t\t\t\t\t\ttargetStrings = [];\n\t\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\tconst elem = keys[i];\n\t\t\t\t\t\t\t\t\t\t\t\tconst key = typeof elem === 'string' ? elem : elem.key;\n\t\t\t\t\t\t\t\t\t\t\t\tlet translatedMessage = translations[key];\n\t\t\t\t\t\t\t\t\t\t\t\tif (translatedMessage === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttranslatedMessage = defaultMessages[i];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\ttargetStrings.push(translatedMessage);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ttargetStrings = defaultMessages;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ttarget[module] = targetStrings;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\twrites.push(writeFile(path.join(coreLocation, bundle.replace(/\\//g, '!') + '.nls.json'), JSON.stringify(target)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twrites.push(writeFile(translationsConfigFile, JSON.stringify(packConfig.translations)));\n\t\t\t\t\t\t\t\treturn Promise.all(writes);\n\t\t\t\t\t\t\t}).then(() => {\n\t\t\t\t\t\t\t\tperf.mark('code/didGenerateNls');\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}).catch(err => {\n\t\t\t\t\t\t\t\tconsole.error('Generating translation files failed.', err);\n\t\t\t\t\t\t\t\treturn defaultResult(locale);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tconsole.error('Generating translation files failed.', err);\n\t\t\treturn defaultResult(locale);\n\t\t}\n\t}\n\n\treturn {\n\t\tgetNLSConfiguration\n\t};\n}\n\n\nif (typeof define === 'function') {\n\t// amd\n\tdefine(['path', 'fs', 'vs/base/common/performance'], function (path, fs, perf) { return factory(require.__$__nodeRequire, path, fs, perf); });\n} else if (typeof module === 'object' && typeof module.exports === 'object') {\n\tconst path = require('path');\n\tconst fs = require('fs');\n\tconst perf = require('../common/performance');\n\tmodule.exports = factory(require, path, fs, perf);\n} else {\n\tthrow new Error('Unknown context');\n}\n"],"mappings":"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","names":[],"file":"languagePacks.js"}